# 设计模式
## 设计模式分为三大类：
- 创建型模式：
工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

- 结构型模式：
适配器模式、合成模式、装饰者模式、代理模式、享元模式、门面模式、桥接模式。

-  行为型模式：
策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、调停者模式、解释器模式。

## 面向对象设计的基本原则：
### 总原则-开闭原则：
对扩展开放，对修改关闭，不允许更改系统的抽象层和已有的实现层，允许添加新的实现。使程序的扩展性好，易于维护和升级。

### 单一职责原则 ：
如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。

### 里氏替换原则 ：
任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当子类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而类也能够在基类的基础上增加新的行为

### 依赖倒置原则 ：
依赖与抽象，而不依赖于具体实现。使用对象时，如果这个对象有一个抽象类型，应当使用这个抽象类型作为变量的静态类型。

### 接口隔离原则 ：
客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。接口应该尽量细化，一个接口对应一个功能模块，同时接口里面的方法应该尽可能的少，使接口更加轻便灵活。

### 迪米特原则 ：
一个对象应对其他对象尽可能少的了解。成员变量、方法参数、方法返回值之外的陌生的类不要作为局部变量出现在类中。

### 合成复用原则：
尽量使用组合，少用继承

## 接口与抽象类：
抽象类不能被实例化，设计师设计一个抽象类，一定是用来继承的，而具体类不是用来继承的，只要有可能，尽量不要从具体类继承。
抽象类应当具有尽可能多的共同代码：在一个抽象类到多个具体类的继承体系中，共同的代码应尽量的移到抽象类中。把重复的代码从子类移动到超类中，可以提高代码的复用率，当代码需要发生改变时，设计师只需要修改一个地方。
抽象类应当拥有尽可能少的数据：一个对象的数据不论是否使用都会占用资源，因此数据应当尽量放到具体类或者等级结构的末端。

### java API 违反里氏替换原则的反面教材：
properties 继承自Hashtable类。hashtable是可以接受除null 以外任何类型的key和value的，但properties 只能接受string类型的key和value,而不能接受某些特殊类型如引用类型作为key或value。这意味着在父类Hashtable出现的地方不能使用properties替代，违反了里氏替换原则。

### 变量的静态类型和真实类型
变量被声明时的类型称为变量的静态类型，变量所引用对象的真实类型叫做变量的真实类型

```
List list = new ArrayList<>();
```

list的静态类型是List,真实类型是ArrayList;
当我们需要引用一个对象时，如果这个对象有一个抽象类型，应当使用这个抽象类型作为变量的静态类型。
即尽量不要定义下面的语句：

```
ArrayList list = new ArrayList<>();
```

而应定义成

```
List list = new ArrayList<>();
```

后者的好处是，在需要将ArrayList替换为LinkedList或者vector类型时，不需要做太多的代码修改，这是多态的一种运用，也是依赖倒置和面向接口编程的体现，它使得程序具有更好的灵活性。

### 动态但分派与静态多分派
java的动态分派仅仅会考虑方法的所有者是哪个对象，因此属于单分派，java的静态分派即对重载方法的分派会考虑到方法的参数类型，因此属于多分派。方法重载是静态多分配，根据对象的静态类型决定调用哪个方法，而方法重写是动态单分派，根据对象的实际类型决定调用哪个方法体。

接口是定义混合类型的理想工具，所谓混合类型，就是在一个类主要类型之外的次要类型。一个混合类型表明，一个类不仅仅具有某个主要类型的行为，还具有其他的次要行为。抽象类不适合定义混合类型，因为java的类是单继承的，如果某一个类已经继承了一个抽象类，要想让这个类再具有次要的行为，就必须将这个次要行为的抽象类插入继承体系中，这会影响到继承体系下游所有的具体实现类。
例如HashTable的主要类型是Map，它的次要类型是Cloneable和Serializable，前者说明HashTable是一个map类型集合，后者表示它还是可以被克隆和可序列化的。

抽象类能够提供一些默认的实现，将重要的宏观逻辑以及子类共用的方法在抽象类中实现，再定义一些抽象方法，迫使子类去实现一些可以差异化的细节逻辑。这就让子类用尽可能少的代码达到了不同实现类有不同的实现，实现的差异就体现在这些抽象方法上，而大的宏观逻辑是共同的，这是模板方法设计模式，也是抽象类相比接口唯一的优点。

### 接口与抽象类的联合使用
由于java抽象类具有提供缺省实现的优点，而接口具有其他所有的优点，所以联合两者使用就是一种很好的选择。声明类型的工作由java 接口承担，同时给出一个抽象类，提供这个接口的一种默认实现。其他同属于这个类型的具体实现类，可以选择实现接口，也可以选择继承抽象类，如果直接实现接口的话，那它需要自己实现这个接口中所有的方法，相反，如果它继承抽象类，相当于遵循某种大的宏观逻辑，只需自己去实现一些差异化的细节方法，省去一些不必要的方法实现。如果实现类选择了继承抽象类，那么当接口中添加方法时，只需要在抽象类中添加相应的方法，所有继承自这个抽象类的子类都不必去实现这个新添加的方法，这就是缺省适配模式。
java语言的API中也运用了这种缺省适配模式，且全部遵循一定的命名规范：Abstract + 接口名，
如Map与AbstracMap,List与AbstractList。
联合使用接口和抽象类可以充分利用两者的优点，克服两者的缺点。

### 定制服务：
定制服务也是一个重要的设计原则，它的意思是说，如果客户端仅仅需要一些方法的话，那么就应当向客户端提供这些需要的方法，而不要提供不需要的方法。为一个角色提供宽、窄两个不同的接口，以对付不同的客户端。因为向客户端提供的public接口是一种承诺，一个public接口一旦提供，就很难撤回，撤回public接口，将会使原有使用这些接口的客户端面临崩溃的风险。作为软件提供商，没有人愿意做出过多的承诺，特别是不必要的承诺。

